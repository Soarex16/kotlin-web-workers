# Sync meeting

## Задачи:

- [ ] что делать в случае библиотечного кода - как его красить?
    - есть тупой workaround - wrapper типы/функции над библиотечным кодом с нужными аннотациями
    - есть уродливый вариант - external annotations как в идее https://www.jetbrains.com/help/idea/external-annotations.html
        - это компилятор поддерживает даже https://discuss.kotlinlang.org/t/how-to-use-external-annotation-on-command-line/973
        - но ["Our experience has shown that external annotations are not a good fit for the Kotlin workflow"](https://github.com/JetBrains/kannotator#kotlin-and-kannotator)
    - можно stdlib и прочие дефолтные вещи, про которые мы знаем помаркать, а остальное (как const eval) требовать явно как часть контракта <- выглядит самым адекватным вариантом
    - если используем функцию из красного кода - кидать ворнинг, если используем функцию из зеленого кода
- [2] прототип
    Сейчас у нас есть простой визитор, который тупо строит список "кто кого вызывает"
    - [x] избавиться от мультинод, поскольку мы решили все виртуальности решить обрубать и требовать явную раскраску

    - составить более подробный план как будем делать прототип
        - [x] берем какую-то аннотацию
            - пока можно захардкодить ее
        - [x] строим граф
            - [x] на графе должны быть какие-то метки - цвета
            - [x] для цветов у нас должна быть логика для построения решеток
        - запускаем анализ на графе
            - [x] откуда? надо определиться что у нас root-ы (например, прогнать reverse top sort)
                - topsort должен обрабатывать циклы (стягиваем их в одну вершину?)
        - далее делаем fixpoint

- [1] документ на обсуждение с Акифом и Антоном
    постоянно возвращалис к примеру - есть основной код, есть две функции, помеченные разными цветами и зависяьт от 3 класса имеющего другой цвет
    вопрос - красим в 4 цвет (смесь цветов?) или в основной цвет?
    4 цвет закрывает вопрос с библиотеками (можно показать ворнинг что вызываем либу из двух разных цветов)

    если будем использовать битовые маски для цветов, то получим решетку (относительно или), если будем просто чиселки, то плохо
    еще битмаск решает проблему если у нас были цвет желтый, красный вызывают зеленый код

    Есть безопасный код (основной модуль), уже загруженный
    Любая функция может вызывать зеленый код

    Если есть незагруженный код, то надо его сначала загрузить. 
    соответственно незагруженный код мы вызывать просто так не можем. И мы помечаем его меткой
    Если юзать битовые маски, то ему просто какой-то бит выделяем.

    Разные чанки в ленивой загрузке будут иметь разные битики

    **В битиках кодируем то, из каких артефактов вызывается данный кусок кода**

O, A, B, C
O - main module
A, B - user defined lazy loaded modules - when we try to call them from O, the compiler emits warning.
C - called from both A and B - question is, whether to warn about its usage?

If we depict A as 01, and B as 10, then C is depicted as A | B = 11. In this case, usages calls 0 -> C will become warnings, as well as calls A -> C and B -> C, but calls A -> O, B -> O, C -> O and C -> A and C -> B are completely fine, since their right-hand side module are already loaded.

## Вопросы:

## Заметки:
    - интересная штука https://glean.software
    сама идея забавная - представляем связи в коде как факты, 
    тогда можем математический аппарат натравить, 
    может еще что-то инкрементальное, и soufle можно попробовать притянуть за уши

### Литература: