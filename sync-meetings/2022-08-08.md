# Sync meeting

## Задачи:

- [x] чекер на фронтенде для поиска обращений к DOM
    - составить список граничных случаев:
        - рекурсия (прямая, взаимная, косвенная) - bfs + visited[]
        - транзитивные зависимости - foo() -> bar() -> window - вроде корректно обрабатываем
        - external вызовы (js функции и прочее)
        - js("window")
        - dynamic

- [x] проверить работу IC
    - есть тесты на IC
    - compiler/incremental-compilation-impl/test/org/jetbrains/kotlin/incremental/IncrementalJsCompilerRunnerTestGenerated.java
    - есть обычные .kt файлы, есть .kt.new (добавление нового файла), .kt.new.### - новая версия файла
    - перегенировать тесты (generate ALL tests) при добавлении своих

    Без тестов понятно, что неработает
    C IC воркеры не будут работать, тут в обход генерации entry-point модулей идет code gen

- [ ] потрассировать jvm backend
    - ClassCodegen
    - InstructionAdapter

- [ ] Подумать как сделать поддержку Browser/NodeJS
    - можно сделать module origin как у IrDeclaration, тогда можно рядом с типом модуля (umd, amd) это приделать

- [x] связаться в слаке Victor Turansky предложить поковырять дебажную сборку
    - [x] Подготовить артефакты, написать инструкцию по установке
    - [x] Тестовый проект
    - [ ] README
    ждем обратную связь

- [x] написать ребятам из JB Space

- [ ] хотим проковырять дырки на этапе кодогенерации
    - wasm - Слава
    - jvm - Ильмир
    - native - ???

## Вопросы:

- покажем прототип, а потом будем заниматься улучшением прототипа 
- можем показать прототип как дебажную сборку компилятора
- дополнительно сделать плагин, который использует дырки

## Заметки:

- записывать кейсы для тестов
- не учтен случай, когда переменная доступна и из лексического скоупа воркера и из остального кода
```kotlin
fun main() {
    count += 1
}

var count = 0

@WebWorker("demo_worker")
fun worker(self: DedicatedWorkerGlobalScope) {
    ...
    count += 1
    ...
}
```
- `importScripts` загрузку скриптов делает синхронно
- IC генерирует код через `generateSingleWrappedModuleBody`, т.е. воркеры не будут работать

- Текущий опыт работы с воркерами space
    1. Push notifications (хватает JS, нет особой логики обработки объектов), чисто ServiceWorker-ы
    2. Синхронизация между всеми вкладками, CacheStorage, используется ServiceWorker, потому что safari не умеет в SharedWorker
        хочется писать на котлине, есть знание доменной модели кешей
    3. Дальше хочется переносить всякие штуки
        Есть арены - реактивность
        Реагирует на изменение сущности на сервере и обновляет на клиенте
        Сейчас на каждую вкладку один коннект, состояние не шарится. Хочется выносить часть приложения с данными в SharedWorker.
        Арена - реактивный кеш с синхронизацией с сервером. Пример: чат; люди в организации - persistence arena

        Обобщая: есть ресурс (соединение с сервером), который хочется шарить между вкладками
    4. Есть узкие места в производительности, которую просто можем вынести в worker (например, парсинг документов и т.д.)

    Бандлинг - котлин генерирует жирные бандлы. Воркер как отдельный бандл - больно жирно, не улучшает UX.
    space собирается так, что отдельные модули собираются в отдельные js-ники (-Xper-module, называют их "доменные модули").

    Хочется шарить код между воркеров и главным модулем.

    Хочется проверки structured cloning при пересылке данных в compile-time. Потому что kotlin по-другому представляет объекты. Надо научиться работать с подмножеством котлиновских классов.

    **ИТОГО: коммуникация и бандлинг. Performance тоже важно, но не так критично. Парсинг markdown**

    - Expect/actual круто, но модель компиляции у него не позволяет выделять common модули
    - compile time проверки на использовани API могут не сработать (сторонние js либы)
    - спросить у Димы где происходит рассахаривание expect/actual
    - ServiceWorker-ы тоже надо учитывать, потому что у них важна генерация в отдельный JS файл
    - inline-worker-ы интересно, но не решает все проблемы

    https://partytown.builder.io/

    Зачастую тяжелые процессы не надо выполнять параллельно. Проще показать крутилку и подождать.

    Пересылка котлиновских классов - это проблема. Можно попробовать выделить подмножество типов, которые можно передавать (любой data-class без методов, например).

- более умное управление зависимостями и бандлами (распил). хотим частичный file2file. Отдельный файл из модуля и генерим js.
```kotlin
@file:SeparateBundle("foo.js", kind = FragmentKind.Lazy)

package mpp.test

fun foo() = "Hello"
```

1. Возвращает Promise или является suspend
2. Suspend properties запрещены
3. Интерфейсы, аннотации, т.е. что делать с декларациями, которые не попадают в .js файл. Сделать диагностики, мол зачем тебе в этом файле интерфейс (или в обратную сторону, ты обращаешься к чему-то извне)