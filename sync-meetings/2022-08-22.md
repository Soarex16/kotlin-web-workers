# Sync meeting

## Задачи:

- [x] причесать код в PR
    - закомментированный код
    - оставить 2 коммита - плагин и дырки в компиляторе

- [x] составить набросок дизайна для веб-воркеров с аннотацией типа RestrictSuspension
    - посмотреть как устроен RestrictSuspension
        - посмотреть чекер для RestrictSuspension в компиляторе
    - придумать способ запрета доступа к глобальному объекту (window) из лямбд с context receiver-ом этого класса, который помечен этой аннотацией

    Есть такой вариант.

    ```kotlin
    @RestrictedContext
    interface WorkerScope {
        @Deprecated(DeprecationLevel.ERROR)
        val document: Any
    }

    context(WorkerScope) fun workerFun() {}

    // Usual code
    with(object: WorkerScope { override val ... }){
        workerFun()
    }

    // Worker code already has `context(WorkerScope)`
    workerFun() // нельзя позволять вызывать тут функции, которые не помечены контекстом WorkerScope
    ```
    
    Надо пописать какой-нибудь пример на котлине, чтобы понять насколько раздражает постоянно писать `context(WorkerScope)`.

        - Лично меня не сильно раздражает, если аннотация вешается на объект, чтобы в with можно было просто передать WorkerScope
        - Но возникает проблема вызова всякого библиотечного кода. Нужно придумать способ обхода таких случаев (может еще одна аннотация ???)
    
    - требовать context receiver
    Надо добавить проверки, что внутри worker функции нельзя вызвать обычные функции

    По сути надо реализовать RestrictSuspension, но для воркеров

    - нужно предусмотреть случай вызова в лямбдах (учитываются ли inline лямбды ???)

## Вопросы:

## Заметки:

Code coloring по сути сводится к тому, что есть обычный контекст и какие-то специальные контексты, которые имеют какие-то ограничения по сравнению с обычным.

То, что мы сейчас сделали (и RestrictSuspension) можно считать некоторой формой контрактов  